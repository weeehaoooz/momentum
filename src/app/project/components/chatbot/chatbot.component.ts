import { Component, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { AiService, ChatMessage } from '../../services/ai.service';
import { ProjectService } from '../../services/project.service';

interface UiChatMessage {
    id: string;
    text: string;
    sender: 'user' | 'ai';
    timestamp: Date;
}

import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';

@Component({
    selector: 'mom-chatbot',
    standalone: true,
    imports: [CommonModule, FormsModule, MatButtonModule, MatIconModule, MatMenuModule],
    templateUrl: './chatbot.component.html',
    styleUrls: ['./chatbot.component.scss']
})
export class ChatbotComponent {
    private aiService = inject(AiService);
    private projectService = inject(ProjectService);

    messages = signal<UiChatMessage[]>([
        {
            id: '1',
            text: 'Hello! I can help you identify and create issues. What would you like to do?',
            sender: 'ai',
            timestamp: new Date()
        }
    ]);

    newMessage = signal('');
    isLoading = signal(false);

    sendMessage() {
        const text = this.newMessage().trim();
        if (!text || this.isLoading()) return;

        // Add user message
        this.addMessage(text, 'user');
        this.newMessage.set('');
        this.isLoading.set(true);

        // Prepare conversation history for AI
        const history = this.messages().map(m => ({
            role: m.sender === 'user' ? 'user' : 'assistant',
            content: m.text
        } as ChatMessage));

        this.aiService.sendMessage(history).subscribe({
            next: (response: any) => {
                const content = response.choices[0].message.content;
                this.handleAiResponse(content);
                this.isLoading.set(false);
            },
            error: (err) => {
                console.error('AI Error:', err);
                this.addMessage('Sorry, I encountered an error connecting to the AI.', 'ai');
                this.isLoading.set(false);
            }
        });
    }

    private handleAiResponse(content: string) {
        try {
            let jsonContent = content;
            // Check for markdown code blocks
            const codeBlockMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
            if (codeBlockMatch) {
                jsonContent = codeBlockMatch[1];
            } else {
                // Try to find the first '{' and the last '}'
                const firstOpen = content.indexOf('{');
                const lastClose = content.lastIndexOf('}');
                if (firstOpen !== -1 && lastClose !== -1 && lastClose > firstOpen) {
                    jsonContent = content.substring(firstOpen, lastClose + 1);
                }
            }

            // Try to parse as JSON
            const data = JSON.parse(jsonContent);

            if (data.action === 'create_issues' && Array.isArray(data.data)) {
                // It's a command to create multiple issues
                this.createIssues(data.data);
                this.addMessage(`I've created ${data.data.length} task(s).`, 'ai');
            } else if (data.action === 'create_issue' && data.data) {
                // Fallback for single issue if AI still uses old format
                this.createIssue(data.data);
                this.addMessage(`I've created the task: "${data.data.title}"`, 'ai');
            } else {
                // It's JSON but not a known command, treat as text
                // If we extracted JSON but it wasn't a command, maybe we should still show the original content?
                // For now, let's show the original content if it's not a command.
                this.addMessage(content, 'ai');
            }
        } catch (e) {
            // Not JSON, treat as normal text response
            this.addMessage(content, 'ai');
        }
    }

    private createIssue(issueData: any) {
        // We need the current project code. 
        // Since ChatbotComponent is inside OverviewComponent, we can get it from ProjectService if it holds the state.
        // ProjectService.project is a signal.
        const currentProject = this.projectService.project();

        if (currentProject) {
            const payload = {
                projectCode: currentProject.code,
                issue: {
                    // ID is generated by ProjectService
                    title: issueData.title,
                    description: issueData.description,
                    status: issueData.status || 'TODO',
                    priority: issueData.priority || 'MEDIUM',
                    created_at: new Date(),
                    updated_at: new Date()
                }
            };
            this.projectService.createIssue(payload);
        } else {
            this.addMessage('Error: No active project found to create the issue in.', 'ai');
        }
    }

    clearChat() {
        this.messages.set([]);
        this.addMessage('Chat cleared. How can I help you?', 'ai');
    }

    private createIssues(issuesData: any[]) {
        const currentProject = this.projectService.project();

        if (currentProject) {
            const newIssues = issuesData.map(issueData => ({
                // ID is generated by ProjectService
                title: issueData.title,
                description: issueData.description,
                status: issueData.status || 'TODO',
                priority: issueData.priority || 'MEDIUM',
                created_at: new Date(),
                updated_at: new Date()
            }));

            const payload = {
                projectCode: currentProject.code,
                issues: newIssues
            };
            this.projectService.createIssues(payload);
        } else {
            this.addMessage('Error: No active project found to create the issues in.', 'ai');
        }
    }

    private addMessage(text: string, sender: 'user' | 'ai') {
        this.messages.update(msgs => [
            ...msgs,
            {
                id: crypto.randomUUID(),
                text,
                sender,
                timestamp: new Date()
            }
        ]);
    }
}
